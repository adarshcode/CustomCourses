# Computer Program Execution: From Source Code to CPU
> **A Step-by-Step Journey Through How Programs Really Work**

## üéØ Course Philosophy

This course is designed to build your understanding **gradually** - starting with simple, intuitive concepts and slowly building to more advanced topics. We focus heavily on **why** things work the way they do, not just **how** to implement them.

### Our Teaching Approach

**üßí Explain Like I'm 5 (ELI5)**: Every concept starts with simple analogies and visual metaphors that anyone can understand.

**üìö Conceptual Foundation**: We build solid theoretical understanding before showing any code.

**üë®‚Äçüíª Developer Perspective**: Technical explanations focus on concepts and design decisions, not complex implementations.

**üîß Simple Examples**: Code examples illustrate concepts clearly without overwhelming complexity.

---

## üìñ Course Structure

### [Chapter 1: What Happens When You Run a Program?](./chapters/01-what-happens-when-you-run-a-program.md)
*The complete journey from double-click to execution*
- The big picture: From your click to CPU instructions
- Source code: What it really is and why computers can't read it directly
- Translation methods: Compilation, interpretation, and the hybrid approach
- Loading: How programs get from storage into memory
- **Simple Examples**: Basic program structure and execution

### [Chapter 2: How Computers Multitask](./chapters/02-how-computers-multitask.md)
*Understanding processes, threads, and scheduling*
- The illusion of simultaneity: How one CPU runs many programs
- Processes: Your program's private workspace
- Threads: Multiple workers in the same workspace  
- Context switching: The incredible juggling act
- **Simple Examples**: Creating and managing threads

### [Chapter 3: Concurrency vs Parallelism](./chapters/03-concurrency-vs-parallelism.md)
*The fundamental difference between dealing with and doing multiple things*
- Understanding concurrency: Managing multiple tasks (juggling analogy)
- Understanding parallelism: Actually doing multiple things simultaneously
- Asynchronous programming: Doing other work while waiting
- **Simple Examples**: Async/await patterns and parallel processing

### [Chapter 4: Memory Management - Stack vs Heap](./chapters/04-memory-management-stack-vs-heap.md)
*How programs organize and manage memory*
- Memory organization: Stack for temporary data, heap for dynamic allocation
- Memory allocation strategies: When and why to use each region
- Garbage collection: Automatic memory cleanup
- **Simple Examples**: Memory allocation patterns and optimization

### [Chapter 5: Compilation and Runtime Systems](./chapters/05-compilation-and-runtime-systems.md)
*From source code to executable programs*
- The compilation spectrum: Ahead-of-time vs just-in-time compilation
- Runtime systems: Virtual machines and managed execution environments
- Performance trade-offs: Compilation time vs execution speed
- **Simple Examples**: Different compilation approaches in practice

### [Chapter 6: Operating System Integration](./chapters/06-operating-system-integration.md)
*How programs interact with the operating system*
- System calls: The bridge between programs and OS services
- File systems: How programs access persistent storage
- Security models: Process isolation and permission systems
- **Simple Examples**: File operations and system resource access

### [Chapter 7: Performance Optimization and Profiling](./chapters/07-performance-optimization-and-profiling.md)
*Measuring and improving program performance*
- Performance metrics: Understanding latency, throughput, and resource usage
- Profiling techniques: Finding bottlenecks in your programs
- Optimization strategies: Code-level and architectural improvements
- **Simple Examples**: Performance measurement and optimization techniques

### [Chapter 8: Modern Development Practices](./chapters/08-modern-development-practices.md)
*How program execution concepts apply to contemporary software development*
- Containerization: Consistent execution environments with Docker
- Microservices: Breaking applications into independent services
- CI/CD pipelines: Automated build, test, and deployment
- Cloud computing and serverless: Modern execution environments
- **Simple Examples**: Real-world application of fundamental concepts

### [Chapter 9: Networking and Web Technologies](./chapters/09-networking-and-web-technologies.md)
*How programs communicate across the internet and what happens when you browse the web*
- Networking fundamentals: How computers communicate across networks
- The web browsing journey: From URL to webpage in your browser
- Real-world applications: Video calls, streaming, gaming, and mobile apps
- Security and privacy: How your data travels safely across the internet
- **Simple Examples**: Daily technology use explained with networking concepts

---

## üöÄ Getting Started

**Prerequisites**: Basic understanding of programming (any language)

**Recommended Path**: 
1. Read each chapter completely before moving to the next
2. Focus on understanding concepts before worrying about implementation details
3. Try the examples to see concepts in action
4. Return to earlier chapters when advanced topics reference foundational concepts

**Time Investment**: 
- Each chapter: 45-60 minutes of focused reading
- Complete course: 9-11 hours spread over multiple sessions
- Recommended pace: 1-2 chapters per day for deep understanding

---

## üí° What Makes This Course Different

- **Theory-First Approach**: We explain WHY before HOW, building strong conceptual foundations
- **Progressive Complexity**: Each concept builds naturally on previous ones
- **Dual Explanations**: Every concept explained both simply (ELI5) and technically (Developer level)
- **Real Understanding**: Focus on mental models, not just syntax
- **Practical Relevance**: Every concept connects to real-world software development
- **Complete Coverage**: From fundamental execution to advanced system design and interview preparation

## üéØ Learning Outcomes

By completing this course, you will understand:

**Fundamental Concepts:**
- How source code becomes running programs
- How computers manage multiple programs simultaneously
- How memory is organized and managed
- How programs interact with operating systems

**Modern Practices:**
- How containerization changes program deployment
- How microservices affect program architecture  
- How CI/CD automates the development lifecycle
- How cloud computing abstracts hardware concerns
- How networking enables global-scale applications
- How web technologies power daily digital experiences

**Performance & Optimization:**
- How to measure and improve program performance
- How to identify and resolve bottlenecks
- How to design systems that scale effectively

---

**Ready to understand how programs really work?** 


**[Start with Chapter 1: What Happens When You Run a Program? ‚Üí](./chapters/01-what-happens-when-you-run-a-program.md)**
